-- Enable pgvector extension
CREATE EXTENSION IF NOT EXISTS vector;

-- Add embedding column (this will be generated by Drizzle)
ALTER TABLE "tools" ADD COLUMN "embedding" vector(1536);

-- Create index for embeddings
CREATE INDEX IF NOT EXISTS tools_embedding_idx ON tools 
USING hnsw (embedding vector_cosine_ops);

-- Create hybrid search function
CREATE OR REPLACE FUNCTION hybrid_tool_search(
  query_text text,
  query_embedding vector(1536),
  match_count integer DEFAULT 10,
  full_text_weight double precision DEFAULT 1.0,
  semantic_weight double precision DEFAULT 1.5,
  min_similarity double precision DEFAULT 0.1
)
RETURNS TABLE (
  id uuid,
  name text,
  short_description text,
  category text,
  similarity float,
  rank float
)
LANGUAGE plpgsql
AS $$
DECLARE
  full_text_query tsquery;
BEGIN
  full_text_query := plainto_tsquery('english', query_text);
  
  RETURN QUERY
  SELECT
    tools.id,
    tools.name,
    tools.long_description,
    tools.category,
    1 - (tools.embedding <=> query_embedding) AS similarity,
    (
      (ts_rank_cd(
        to_tsvector('english', tools.name || ' ' || tools.long_description || ' ' || tools.category), 
        full_text_query
      ) * full_text_weight) +
      ((1 - (tools.embedding <=> query_embedding)) * semantic_weight) +
      CASE 
        WHEN lower(tools.name) = lower(query_text) THEN 10
        ELSE 0
      END
    ) AS rank
  FROM
    tools
  WHERE
    tools.embedding IS NOT NULL AND
    (
      to_tsvector('english', tools.name || ' ' || tools.long_description || ' ' || tools.category) @@ full_text_query
      OR
      (1 - (tools.embedding <=> query_embedding)) > min_similarity
    )
  ORDER BY
    rank DESC
  LIMIT
    match_count;
END;
$$;
